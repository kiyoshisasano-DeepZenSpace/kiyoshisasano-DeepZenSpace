%%{init: {'theme': 'neutral', 'fontFamily': 'Inter, Roboto, Helvetica, Arial', 'themeVariables': { 'primaryColor': '#f5f7fb', 'primaryBorderColor': '#c7cce1', 'lineColor': '#8a90b4', 'fontSize': '14px'}}}%%
%% PLD → HCI Temporal State Machine Template
%% Usage: replace ALL_CAPS with your project-specific values.
%% This template is GitHub-compatible (Mermaid v10+).

stateDiagram-v2
    %% ---------- Metadata ----------
    %% title: PLD→HCI Temporal State Machine
    %% version: 1.0
    %% last_updated: 2025-10-13
    %% notes: Implement non-blocking latency holds; cap repair attempts; emit schema-compliant logs.

    %% ---------- Entry & Exit ----------
    [*] --> SEGMENT: app_start / initContext()
    SEGMENT --> [*]: app_shutdown / flushLogs()

    %% ---------- Core States ----------
    state "Segment (L₁)
— boundary detection —" as SEGMENT
    state "Drift (L₂)
— deviation / ambiguity —" as DRIFT
    state "Latency Hold (L₃)
— intentional pacing —" as LATENCY_HOLD
    state "Repair (L₂)
— clarification loop —" as REPAIR
    state "Reentry
— resume prior context —" as REENTRY
    state "Resonance (L₅)
— synchronized pacing —" as RESONANCE

    %% ---------- Transitions & Guards ----------
    SEGMENT --> DRIFT: DRIFT_SIGNAL [silence_ms >= 8000 || confidence < 0.5]
/ log('drift_detected')
    SEGMENT --> LATENCY_HOLD: PACING_HINT [suggest_latency_ms]
/ ui.renderHold(τ)
    SEGMENT --> RESONANCE: STABLE_PACING [ρ >= 0.85 && window_s >= 6]

    DRIFT --> LATENCY_HOLD: SUGGEST_LATENCY [600 <= τ <= 1500]
/ ui.renderHold(τ, cancellable=true)
    DRIFT --> REPAIR: DRIFT_CONFIRMED [score >= θ_drift]
/ log('repair_triggered', {attempt})
    DRIFT --> SEGMENT: SELF_CORRECTED / clearDrift()

    LATENCY_HOLD --> REPAIR: HOLD_EXPIRED [drift_active]
/ openClarificationUI()
    LATENCY_HOLD --> SEGMENT: USER_INTERRUPT || (HOLD_EXPIRED && !drift_active)
/ cancelHold()

    REPAIR --> REENTRY: CONFIRM || OPTION_SELECT
/ restoreContext(prior_context_id)
log('reentry_success')
    REPAIR --> REPAIR: FOLLOWUP [attempt < MAX_REPAIR_ATTEMPTS]
/ promptAgain()
    REPAIR --> SEGMENT: FOLLOWUP [attempt >= MAX_REPAIR_ATTEMPTS]
/ log('repair_failed'); handoff()
    REPAIR --> DRIFT: TIMEOUT / log('repair_failed'); backoff()

    REENTRY --> RESONANCE: STABLE_ALIGNMENT [ρ >= 0.85 && window_s >= 6]
    REENTRY --> SEGMENT: TASK_SWITCH / saveContext()

    RESONANCE --> SEGMENT: TOPIC_SHIFT || CONTEXT_CHANGE
    RESONANCE --> DRIFT: DRIFT_SIGNAL

    %% ---------- Notes & Styling ----------
    note right of LATENCY_HOLD
      Non-blocking by design:
      - Any user input cancels within ≤50ms
      - Always log latency_hold with duration_ms
    end note

    classDef core fill:#ffffff,stroke:#c7cce1,color:#1d2330;
    classDef active fill:#eef2ff,stroke:#8a90b4,color:#1d2330;
    class SEGMENT,DRIFT,LATENCY_HOLD,REPAIR,REENTRY,RESONANCE core;
