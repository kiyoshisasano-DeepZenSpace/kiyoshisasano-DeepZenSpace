%% PLD Operator Sync Flow (L1–L5) — Sequence Diagram
%% File: operator_sync_flow.mmd

sequenceDiagram
    autonumber
    participant U as User
    participant UI as UI / Orchestrator
    participant L1 as L₁ Segment Detection
    participant L2 as L₂ Drift–Repair
    participant L3 as L₃ Latency (Hold)
    participant L4 as L₄ Feedback Reflex
    participant L5 as L₅ Alignment–Resonance
    participant TSM as Temporal State Machine
    participant BUS as Event Bus (pld_events)
    participant DB as Storage (validated)
    participant M as Metrics/Dashboards

    %% --- Phase: Ongoing Interaction (SEGMENT) ---
    U->>UI: Input / navigation
    UI->>L1: tokens, silence_ms, prosody?
    L1-->>TSM: signal.boundary(start|end)
    Note over L1,TSM: If boundary + low confidence → drift_signal

    %% --- Phase: DRIFT → REPAIR ---
    L1-->>L2: drift_signal (confidence < θ, silence > threshold)
    L2->>BUS: emit drift_detected\nmetadata: {ui_state, drift_type, confidence_score, attempt}
    BUS->>DB: append
    L2->>TSM: enter DRIFT

    %% Hint-only latency suggestion (LLM/policy)
    L2-->>L3: telemetry.suggest_latency_ms=900, reason="soft_repair_probe"
    Note over L2,L3: Model suggests ONLY a hint; UI renders actual delay.

    L2->>BUS: emit repair_triggered\nmetadata: {strategy:"soft_repair", context_id, attempt, latency_before_repair}
    BUS->>DB: append
    L2->>TSM: enter REPAIR

    %% --- Phase: LATENCY_HOLD (UI responsibility) ---
    UI->>L3: renderHold(τ), cancellable<=50ms
    L3->>BUS: emit latency_hold\nmetadata: {duration_ms, reason, context, user_cancelled}
    BUS->>DB: append
    alt user interrupts
        U-->>UI: keypress/click/speech
        UI-->>TSM: exit LATENCY_HOLD → SEGMENT
    else hold expires
        UI-->>TSM: hold_expired
        TSM-->>L2: continue repair flow
    end

    %% --- Phase: REPAIR UI ---
    L2->>UI: show clarification options
    alt user confirms intent
        U->>UI: confirmation / valid option
        UI->>TSM: enter REENTRY
        UI->>BUS: emit reentry_success\nmetadata: {previous_context_id, reentry_lag, reentry_method, goal_completed}
        BUS->>DB: append
    else timeout / failures
        UI->>BUS: emit repair_failed\nmetadata: {failed_attempts, context_id}
        BUS->>DB: append
        TSM-->>L2: cap attempts or handoff
    end

    %% --- Phase: FEEDBACK REFLEX ---
    UI->>L4: feedback.signal (ack/deny/affect)
    L4->>UI: micro-adjust pacing/echo\n(gain_reflex, t_reflex_ms)
    L4-->>BUS: emit reflex (custom)\n{reflex_latency_ms, adjust_type}
    BUS->>DB: append

    %% --- Phase: RESONANCE ---
    UI->>L5: coherence monitor (ρ >= threshold for window_s)
    L5->>TSM: enter RESONANCE
    L5-->>BUS: resonance_start\n{duration_s, ρ_coherence, context_id}
    BUS->>DB: append

    %% --- Exit conditions ---
    alt topic shift or drift again
        L1-->>TSM: boundary/topic_shift
        TSM-->L5: exit RESONANCE
        L5-->>BUS: resonance_end\n{duration_s, ρ_coherence, context_id}
        BUS->>DB: append
        TSM-->L2: DRIFT
    else task completes
        TSM-->UI: SEGMENT idle
    end

    %% --- Metrics pipeline (async) ---
    DB-->>M: compute & visualize\n- drift_to_repair_ratio\n- avg_latency_hold\n- reentry_success_rate\n- repair_loop_depth

    %% --- Policy/Compliance notes ---
    Note over L3,UI: UI must cancel holds ≤50ms on input; no chained holds without user action.
    Note over BUS,DB: Validate against pld_event.schema.json; latency_hold requires metadata.duration_ms.
