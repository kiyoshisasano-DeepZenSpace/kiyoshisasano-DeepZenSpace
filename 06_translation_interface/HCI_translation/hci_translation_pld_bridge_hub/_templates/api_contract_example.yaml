openapi: 3.1.0
info:
  title: PLD Bridge Hub — API Contract (Example)
  version: 1.0.0
  description: |
    Reference API for integrating client UIs, LLM orchestrators, and analytics with the PLD Bridge Hub.
    This contract focuses on **event ingestion**, **validation**, **state sync**, **latency suggestion**,
    and **metrics access**. It aligns with the PLD event schema and HCI translation layer.

servers:
  - url: https://bridge.example.org/api
    description: Production
  - url: https://staging.bridge.example.org/api
    description: Staging

tags:
  - name: Events
    description: Append-only PLD event ingestion and validation.
  - name: Sync
    description: State sync and callbacks across PLD/HCI layers.
  - name: Timing
    description: Latency suggestions and pacing telemetry.
  - name: Metrics
    description: Derived metrics and dashboards.
  - name: Health
    description: Liveness and readiness.
  - name: Admin
    description: Schema and config utilities.

paths:
  /v1/events/ingest:
    post:
      tags: [Events]
      summary: Ingest one or more PLD events (append-only).
      description: |
        Accepts newline-delimited JSON (JSONL) or a JSON array of events.
        Validates against the PLD event schema; rejects invalid records unless `validate=false` is passed.
      parameters:
        - in: query
          name: validate
          schema: { type: boolean, default: true }
          description: Run schema validation before ingest.
      requestBody:
        required: true
        content:
          application/json:
            schema:
              oneOf:
                - $ref: '#/components/schemas/PldEvent'
                - type: array
                  minItems: 1
                  items: { $ref: '#/components/schemas/PldEvent' }
            examples:
              single:
                summary: Single event
                value:
                  event_type: latency_hold
                  timestamp: 2025-10-13T12:00:00Z
                  session_id: S-123
                  metadata:
                    duration_ms: 900
                    reason: soft_repair_probe
                    context: frame:Form_Submitted
                    user_cancelled: false
              batch:
                summary: Batch events
                value:
                  - event_type: drift_detected
                    timestamp: 2025-10-13T12:00:03Z
                    session_id: S-123
                    metadata:
                      ui_state: /checkout/payment
                      drift_type: silence
                      confidence_score: 0.42
                      attempt: 1
                      last_intent: { name: confirm_payment, confidence: 0.42 }
                  - event_type: repair_triggered
                    timestamp: 2025-10-13T12:00:04Z
                    session_id: S-123
                    metadata:
                      strategy: soft_repair
                      latency_before_repair: 0.9
                      context_id: /checkout/payment
                      attempt: 1
      responses:
        '202':
          description: Accepted for processing.
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/IngestResult'
        '422':
          description: Validation failed (when validate=true).
          content:
            application/json:
              schema: { $ref: '#/components/schemas/ValidationError' }

  /v1/events/validate:
    post:
      tags: [Events, Admin]
      summary: Validate events against schema without ingesting.
      requestBody:
        required: true
        content:
          application/json:
            schema:
              oneOf:
                - $ref: '#/components/schemas/PldEvent'
                - type: array
                  minItems: 1
                  items: { $ref: '#/components/schemas/PldEvent' }
      responses:
        '200':
          description: Validation report.
          content:
            application/json:
              schema: { $ref: '#/components/schemas/ValidationReport' }

  /v1/sync/state:
    post:
      tags: [Sync]
      summary: Upsert cross-layer sync state for a session/context.
      description: |
        Bridges UI orchestration, LLM policy decisions, and analytics snapshots.
        Use this to keep **phase**, **anchors**, and **tempo** aligned.
      requestBody:
        required: true
        content:
          application/json:
            schema: { $ref: '#/components/schemas/SyncState' }
            examples:
              reentry_anchor:
                value:
                  session_id: S-123
                  context_id: /checkout/payment
                  phase: REPAIR
                  anchors:
                    previous_context_id: /checkout/payment
                  tempo:
                    suggest_latency_ms: 900
                    resonance_rho: 0.78
                  metadata:
                    source: ui_orchestrator
      responses:
        '200':
          description: State stored.
          content:
            application/json:
              schema: { $ref: '#/components/schemas/SyncAck' }

  /v1/sync/webhooks/reentry:
    post:
      tags: [Sync]
      summary: Webhook callback when a reentry anchor is used.
      description: |
        Called by the UI/Orchestrator when a session resumes a prior context.
        Emits a `reentry_success` event internally and returns the computed lag.
      requestBody:
        required: true
        content:
          application/json:
            schema: { $ref: '#/components/schemas/ReentryUse' }
      responses:
        '200':
          description: Acknowledged and logged.
          content:
            application/json:
              schema: { $ref: '#/components/schemas/ReentryAck' }

  /v1/timing/suggest:
    post:
      tags: [Timing]
      summary: Request a latency suggestion (τ) for a given context/user tempo.
      description: |
        The Bridge Hub returns a **hint** only—clients must render holds and log `latency_hold`.
      requestBody:
        required: true
        content:
          application/json:
            schema: { $ref: '#/components/schemas/TimingContext' }
            examples:
              simple:
                value:
                  session_id: S-123
                  ui_state: /support/triage
                  recent_stats:
                    interrupts_rate: 0.12
                    median_pause_ms: 840
                    drift_count_window: 2
      responses:
        '200':
          description: Suggested timing parameters.
          content:
            application/json:
              schema: { $ref: '#/components/schemas/TimingSuggestion' }

  /v1/metrics/overview:
    get:
      tags: [Metrics]
      summary: Return concise derived metrics about drift/repair/reentry.
      parameters:
        - in: query
          name: from
          schema: { type: string, format: date-time }
        - in: query
          name: to
          schema: { type: string, format: date-time }
        - in: query
          name: ui_state
          schema: { type: string }
      responses:
        '200':
          description: Metrics snapshot.
          content:
            application/json:
              schema: { $ref: '#/components/schemas/MetricsOverview' }

  /v1/health:
    get:
      tags: [Health]
      summary: Liveness/readiness probe.
      responses:
        '200':
          description: OK
          content:
            application/json:
              schema:
                type: object
                required: [status, uptime_s]
                properties:
                  status: { type: string, enum: [ok, degraded] }
                  uptime_s: { type: number }
                  schema_version: { type: string }

  /v1/admin/schema:
    get:
      tags: [Admin]
      summary: Retrieve the active PLD event JSON Schema (server view).
      responses:
        '200':
          description: Current schema (JSON).
          content:
            application/json:
              schema: { $ref: '#/components/schemas/PldEventSchema' }

components:
  schemas:
    # ---- Core PLD Event (aligned to examples in the repo) ----
    PldEvent:
      type: object
      required: [event_type, timestamp]
      additionalProperties: true
      properties:
        event_type:
          type: string
          enum: [drift_detected, repair_triggered, repair_failed, reentry_success, reentry_anchor_set, reentry_missing_anchor, repair_escalation, latency_hold]
        timestamp: { type: string, description: ISO8601 UTC ('...Z') }
        session_id: { type: string }
        metadata:
          type: object
          description: Flexible metadata bag; see event-specific requirements below.
      allOf:
        - if:
            properties: { event_type: { const: latency_hold } }
          then:
            required: [session_id, metadata]
            properties:
              metadata:
                type: object
                properties:
                  duration_ms: { type: number, minimum: 0 }
                  reason: { type: string }
                  context: { type: string }
                  user_cancelled: { type: boolean }
                required: [duration_ms]
                additionalProperties: true

    IngestResult:
      type: object
      required: [accepted, rejected, validation]
      properties:
        accepted: { type: integer, minimum: 0 }
        rejected: { type: integer, minimum: 0 }
        validation:
          type: object
          required: [errors]
          properties:
            errors:
              type: array
              items:
                type: object
                properties:
                  line: { type: integer, minimum: 1 }
                  message: { type: string }

    ValidationError:
      type: object
      required: [errors]
      properties:
        errors:
          type: array
          items:
            type: object
            required: [line, message]
            properties:
              line: { type: integer, minimum: 1 }
              message: { type: string }

    ValidationReport:
      type: object
      required: [valid, invalid, errors]
      properties:
        valid: { type: integer, minimum: 0 }
        invalid: { type: integer, minimum: 0 }
        errors:
          type: array
          items:
            $ref: '#/components/schemas/ValidationError/properties/errors/items'

    SyncState:
      type: object
      required: [session_id, phase]
      properties:
        session_id: { type: string }
        context_id: { type: string }
        phase:
          type: string
          enum: [SEGMENT, DRIFT, REPAIR, LATENCY_HOLD, REENTRY, RESONANCE]
        anchors:
          type: object
          properties:
            previous_context_id: { type: string }
            intent_id: { type: string }
        tempo:
          type: object
          properties:
            suggest_latency_ms: { type: number, minimum: 0 }
            resonance_rho: { type: number, minimum: 0, maximum: 1 }
        metadata:
          type: object
          additionalProperties: true

    SyncAck:
      type: object
      required: [ok]
      properties:
        ok: { type: boolean }
        stored_at: { type: string, format: date-time }

    ReentryUse:
      type: object
      required: [session_id, previous_context_id, reentry_ts]
      properties:
        session_id: { type: string }
        previous_context_id: { type: string }
        reentry_ts: { type: string, format: date-time }

    ReentryAck:
      type: object
      required: [logged, reentry_lag_s]
      properties:
        logged: { type: boolean }
        reentry_lag_s: { type: number, minimum: 0 }

    TimingContext:
      type: object
      required: [session_id, ui_state]
      properties:
        session_id: { type: string }
        ui_state: { type: string }
        recent_stats:
          type: object
          properties:
            interrupts_rate: { type: number, minimum: 0, maximum: 1 }
            median_pause_ms: { type: number, minimum: 0 }
            drift_count_window: { type: integer, minimum: 0 }
            resonance_rho: { type: number, minimum: 0, maximum: 1 }
          additionalProperties: true
        user_prefs:
          type: object
          properties:
            reduced_motion: { type: boolean }
            accessibility_mode: { type: string }

    TimingSuggestion:
      type: object
      required: [suggest_latency_ms, reason]
      properties:
        suggest_latency_ms: { type: number, minimum: 0 }
        reason: { type: string }
        policy_tier:
          type: string
          enum: [T0, T1, T2, T3]
        bounds:
          type: object
          properties:
            min_ms: { type: number, minimum: 0 }
            max_ms: { type: number, minimum: 0 }
          required: [min_ms, max_ms]

    MetricsOverview:
      type: object
      required: [window, counts, ratios]
      properties:
        window:
          type: object
          properties:
            from: { type: string, format: date-time }
            to: { type: string, format: date-time }
        counts:
          type: object
          properties:
            drift_detected: { type: integer, minimum: 0 }
            repair_triggered: { type: integer, minimum: 0 }
            reentry_success: { type: integer, minimum: 0 }
            latency_hold: { type: integer, minimum: 0 }
        ratios:
          type: object
          properties:
            drift_to_repair_ratio: { type: number, minimum: 0 }
            reentry_success_rate: { type: number, minimum: 0, maximum: 1 }
            latency_interrupt_rate: { type: number, minimum: 0, maximum: 1 }

    PldEventSchema:
      type: object
      description: JSON Schema object for PLD events (server authoritative).
      additionalProperties: true
